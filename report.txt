Отчёт на 14.12.2024 о файлах *.py:
Количество файлов - 42
Количество строк - 1578
Количество символов - 58084




------------------------------------------------------------
main.py:

# Импорт библиотек
import asyncio
import signal
import time
import traceback
from data_operators.maps_operator import save_maps_to_file
from core.maps_list import maps

# Инициализируем события
from variables import event_manager

# Запускаем реакторы
from network import call_reaction, text_reaction

# Импорт кастомных функций
from core.time_converter import get_full_current_date
from a_library.log_error import log_error_to_file
from data_operators.BD_init import init_db

# Импорт необходимых переменных
from variables.bot import dp,bot
from mechanics.game_core import process_game

from core import maps_list_operator


async def main():
    asyncio.create_task(process_game())
    await bot.delete_webhook(drop_pending_updates=True)
    print("Leviathan launched successfully")
    await dp.start_polling(bot, skip_updates=True)


async def on_shutdown(dp):
    save_maps_to_file(maps, "maps.json")
    print("Программа завершается... Ожидаю завершения всех задач.")
    await bot.close()


def setup_shutdown():
    signal.signal(signal.SIGINT, lambda sig, frame: on_shutdown(dp))  # Для Ctrl+C
    signal.signal(signal.SIGTERM, lambda sig, frame: on_shutdown(dp))  # Для сигнала завершения процесса


init_db()


# Запуск main в цикле while true
if __name__ == "__main__":
    setup_shutdown()
    log_error_to_file(f"\n\n\n\n\n{'-'*30}\n{' '*13}Start {get_full_current_date()}\n{'-'*30}")
    while True:
        try:
            asyncio.run(main())
        except Exception as error:
            print(f'$ Fatal Error {get_full_current_date()} : ', error)
            log_error_to_file(f'Fatal Error {get_full_current_date()} : '+ str(error) +"\n\n"+traceback.format_exc())




------------------------------------------------------------
progect_info_generator.py:
import os
from datetime import datetime


def generate_report(folder_path: str, file_extension: str, report_name: str, ignored_paths: list) -> None:
    """
    Генерирует отчёт о файлах с указанным расширением в папке и подпапках.

    :param folder_path: Путь к корневой папке.
    :param file_extension: Расширение файлов (например, ".py").
    :param report_name: Имя итогового отчёта (txt-файл).
    :param ignored_paths: Список путей для игнорирования (файлы и папки).
    """
    print('Генерирую отчёт...')

    total_files = 0
    total_lines = 0
    total_chars = 0
    files_data = []

    # Перебор файлов и подсчёт строк и символов
    for root, _, files in os.walk(folder_path):
        # Игнорируем папки и файлы, указанные в ignored_paths
        if any(ignored_path in root for ignored_path in ignored_paths):
            continue

        for file in files:
            if file.endswith(file_extension):
                # Игнорируем файлы по имени
                file_path = os.path.join(root, file)
                if any(ignored_path in file_path for ignored_path in ignored_paths):
                    continue

                total_files += 1
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.readlines()
                    line_count = len(content)
                    char_count = sum(len(line) for line in content)
                    total_lines += line_count
                    total_chars += char_count
                    relative_path = os.path.relpath(file_path, folder_path)
                    files_data.append((relative_path, ''.join(content)))

    # Формирование заголовка отчёта
    date = datetime.now().strftime("%d.%m.%Y")
    report_header = (
        f"Отчёт на {date} о файлах *{file_extension}:\n"
        f"Количество файлов - {total_files}\n"
        f"Количество строк - {total_lines}\n"
        f"Количество символов - {total_chars}\n\n"
    )

    # Запись в итоговый файл
    with open(report_name, 'w', encoding='utf-8') as report_file:
        report_file.write(report_header)
        for file_path, content in files_data:
            report_file.write(f"\n\n\n------------------------------------------------------------\n{file_path}:\n")
            report_file.write(content + "\n")

    print(f"Отчёт сохранён в файл: {report_name}")


if __name__ == "__main__":
    folder = os.path.dirname(os.path.abspath(__file__))  # Путь к текущей папке
    extension = ".py"  # Искомое расширение файлов
    report_file = "report.txt"  # Название файла отчёта
    ignored_paths = ['run', 'venv']  # Список игнорируемых файлов и папок

    generate_report(folder, extension, report_file, ignored_paths)




------------------------------------------------------------
project_path.py:
from os import path


def get_project_path() -> str:
    return path.dirname(path.abspath(__file__))

def get_global_path(local_path):
    return path.join(get_project_path(), local_path)




------------------------------------------------------------
a_library\custom_translator.py:
def Str_in_List2(Str):
    List = []
    Str_ = ''
    for i in Str:
        if i == ','and i != '[' and i != ']':
            try:
                List += [int(Str_)]
            except:
                List += [Str_]
            Str_ = ''
        elif i == ']':
            try:
                List += [int(Str_)]
            except:
                List += [Str_]
            Str_ = ''
        elif i != '[':
            Str_ += i

    return List
def Str_in_List(Str):
    if Str != '':
        List = []
        Str_ = ''
        for i in Str:
            if i == '-' :
                try:
                    List += [int(Str_)]
                except:

                    if Str_[0] == '[' and Str_[-1] == ']':
                        List += [Str_in_List2(Str_)]
                    else:
                        List += [Str_]
                Str_ = ''
            else:
                Str_ += i
        return List
    else:
        return []


def List_in_Str(List):
    Str = ''
    buf_List_in_Str_1 = len(List)
    for i in range(buf_List_in_Str_1):
        Str += str(List[i])
        Str += "-"
    return Str



------------------------------------------------------------
a_library\log_error.py:
# Функция для записи ошибок в файл
def log_error_to_file(message):
    with open("error_log.txt", "a") as file:
        file.write(message + "\n\n\n\n\n")




------------------------------------------------------------
core\action.py:
from enum import Enum


class ActionType(Enum):
    move = 0,
    attack = 1,
    dive = 2


class Action:
    def __init__(self, object_, action_type, value):
        self.object_ = object_
        self.action_type = action_type
        self.value = value




------------------------------------------------------------
core\images_operator.py:
from os import path

import cv2
from aiogram import types
from project_path import get_global_path

cached_cv2_images = dict() # key - путь, value - изображение


def get_cv2_image_from_path(path_):
    if path_ in cached_cv2_images:
        return cached_cv2_images[path_]
    else:
        cached_cv2_images[path_] = cv2.imread(path_, cv2.IMREAD_UNCHANGED)  # Чтение с альфа-каналом
        return get_cv2_image_from_path(path_)

def get_image_path_from_ship_name(ship_name):
    # Определяем корневую папку проекта (там, где лежит основной файл проекта)
    return get_global_path(path.join('sprites', 'ships', f'{ship_name}.png'))

def get_ship_image_from_name(ship_name):
    image_path = get_image_path_from_ship_name(ship_name)
    return get_cv2_image_from_path(image_path)




------------------------------------------------------------
core\maps_list.py:
maps = {}




------------------------------------------------------------
core\maps_list_operator.py:
from models.map import Map
from data_operators.maps_operator import load_maps_from_file
from core.maps_list import maps


try:
    maps.update(load_maps_from_file("maps.json"))
except Exception as exception:
    maps.update({0 : Map()})
    print(f'Ошибка загрузки карт из maps.json: {exception}')

if len(maps) == 0:
    maps[0] = Map()




------------------------------------------------------------
core\map_generator.py:





------------------------------------------------------------
core\time_converter.py:
from datetime import datetime


def get_full_current_date() -> str:
    # Получение текущей даты и времени
    current_datetime = datetime.now()
    # Преобразование в строку
    return current_datetime.strftime("%Y-%m-%d %H:%M:%S")

# Переводит секунды в string отображающий время
def seconds_to_time_string(time_seconds, show_only_parts = 999) -> str:
    if show_only_parts < 1:
        print("Ошибка в seconds_to_time_string(): show_only_parts не может быть менее 1")
        return ""

    days, not_days = divmod(time_seconds, 86400)
    hours, not_hours = divmod(not_days, 3600)
    minutes, not_minutes = divmod(not_hours, 60)
    seconds = not_minutes

    time_string = ""
    showed_parts = 0
    if days > 0:
        time_string += f"{int(days)}д "
        showed_parts += 1
        if showed_parts >= show_only_parts:
            return time_string
    if hours > 0:
        time_string += f"{int(hours)}ч "
        showed_parts += 1
        if showed_parts >= show_only_parts:
            return time_string
    if minutes > 0:
        time_string += f"{int(minutes)}м "
        showed_parts += 1
        if showed_parts >= show_only_parts:
            return time_string
    if seconds > 0 or time_string == "":
        time_string += f"{int(seconds)}с"
    return time_string





------------------------------------------------------------
core\users_list.py:
from models.user import users_id,users_dict




------------------------------------------------------------
core\vector2.py:

class Vector2:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def add(self, delta_pos):
        """Прибавляет к этому вектору другой"""
        self.x += delta_pos.x
        self.y += delta_pos.y

    def summ(self, delta_pos):
        """Возвращает сумму векторов"""
        return Vector2(self.x + delta_pos.x, self.y + delta_pos.y)

    def to_str(self):
        return f'Vector2({self.x}, {self.y})'

    def equals(self, compare_to) -> bool:
        if self.x == compare_to.x and self.y == compare_to.y:
            return True
        else:
            return False




------------------------------------------------------------
core\call_reactions\arrows_reaction.py:
from aiogram import types
from core.maps_list import maps
from core.action import Action,ActionType
from core.users_list import users_dict


async def arrows_reaction(message: types.CallbackQuery):
    """
    Обработчик стрелок передвижения
    """

    if message.data == "↑":
        # Верх
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, 0))

    elif message.data == "←":
        # Влево
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, 90))

    elif message.data == "→":
        # Вправо
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, -90))

    elif message.data == "↓":
        # Вниз
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, 180))

    elif message.data == "⬈":
        # Правый верхний угол
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, -45))


    elif message.data == "⬉":
        # Левый верхний угол
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, 45))


    elif message.data == "⬋":
        # Левый нижний угол
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, 135))


    elif message.data == "⬊":
        # Правый нижний угол
        maps[0].add_new_delayed_action(Action(users_dict[message.message.chat.id].controlled_ship, ActionType.move, -135))




------------------------------------------------------------
core\call_reactions\cancel_reaction.py:
import asyncio

from aiogram import types

from core.maps_list import maps
from core.users_list import users_dict
from UI import map_visualizer


async def cancel_reaction(message: types.CallbackQuery):
    """Обработчик кнопки отмены хода"""
    if message.data == "cancel":
        if message.message.chat.id in users_dict and users_dict[message.message.chat.id].current_map is not None and users_dict[message.message.chat.id].controlled_ship is not None:
            maps[users_dict[message.message.chat.id].current_map].cancel_object_delayed_actions(users_dict[message.message.chat.id].controlled_ship)
            asyncio.create_task(map_visualizer.update_map_message_of_user(users_dict[message.message.chat.id], True))




------------------------------------------------------------
core\text_reactions\map_reaction.py:
import asyncio
from random import randint

from aiogram import types
from UI.inline_keyboard_buttons import ship_control_buttons
from UI.map_visualizer import update_map_message_of_user
from network import async_messages_operator
from core.vector2 import Vector2
from core.maps_list import maps
from models import user
from models.world_objects.ship import Ship
import random

async def map_button_reaction(message: types.Message):
    """
    Обработчик текстовой кнопки Карта 🗺
    """
    # Проверяем команду
    if message.text == "Карта 🗺":
        # Получаем пользователя
        user_ = user.users_dict[message.chat.id]

        # Проверка есть ли у игрока корабль
        if user_.controlled_ship is None:
            player_ship = Ship(position=Vector2(randint(-2, 2), randint(-2, 2)), rotation=0, sprite_name=f'ship {randint(1, 5)}')
            player_ship.register_owner(user_)
            maps[user_.current_map].add_new_object(player_ship)
        else:
            for i in maps.keys():
                for object_ in maps[i].objects:
                    if type(object_) == Ship:
                        if object_.owner.id == user_.id:
                            user_.controlled_ship  =  object_
                            break


        # Удаляем старую карту если она была и отсылаем новую
        asyncio.create_task(async_messages_operator.try_delete_message(user_.id, user_.map_message_id))
        user_.map_message_id = None
        asyncio.create_task(update_map_message_of_user(user_))




------------------------------------------------------------
core\text_reactions\start_reaction.py:
import asyncio, os

from aiogram.enums import ParseMode

from variables.bot import bot
from models.user import User
from UI.keyboard_buttons import button_map

from aiogram import types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton


async def command_start(message: types.Message):
    """
    Обработчик команды /start.
    """
    #print('t', message.text, message.text == "/start")

    # Проверяем, что команда "/start"
    if message.text == "/start":
        caption = '''Добро пожаловать в мир Харибды! 🌊

Мир поглощён океаном, монстры держат остатки человечества в страхе, а вы – капитан корабля, который должен выжить и помочь восстановить цивилизацию. 🚢

- Управляйте своим кораблём.
- Исследуйте затонувшие города.
- Сражайтесь с монстрами и пиратами.
- Помните: одна ошибка – и всё потеряно.
⚓ Нажми *Карта* 🗺, чтобы начать своё путешествие:

Удачи, капитан! Только вы можете изменить судьбу человечества. 🌌'''

        photo = types.FSInputFile("sprites/intro_image.webp")

        # Отправляем фото с текстом и кнопками
        await message.bot.send_photo(
                    chat_id=message.chat.id,
                    photo=photo,
                    caption=caption,
                    parse_mode=ParseMode.MARKDOWN,
                    reply_markup = button_map
                )





------------------------------------------------------------
data_operators\BD_init.py:
import sqlite3
import os
from a_library.custom_translator import List_in_Str, Str_in_List

# Имя файла базы данных
DB_FILE = os.path.join(os.path.dirname(__file__), "local_database.db")

def init_db():
    try:
        # Подключаемся к локальной базе данных (файл создается автоматически, если его нет)
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            # Создаем таблицу
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS example_table (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    artefact TEXT,
                    special_info TEXT,
                    checking_ship INTEGER DEFAULT 0,
                    current_map INTEGER DEFAULT 0
                )
            """)
            print("Таблица успешно создана!")
    except Exception as e:
        print(f"Ошибка при инициализации базы данных: {e}")

def add_user(user_id, name, artefact=None, special_info=None, current_map=None):
    artefact = artefact or []
    special_info = special_info or []
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            # Добавляем пользователя
            cursor.execute("""
                INSERT INTO example_table (id, name, artefact, special_info, current_map)
                VALUES (?, ?, ?, ?, ?)
            """, (user_id, name, List_in_Str(artefact), List_in_Str(special_info), current_map))
            print(f"Пользователь '{name}' успешно добавлен!")
    except Exception as e:
        print(f"Ошибка при добавлении пользователя: {e}")

def get_user(user_id):
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            user = cursor.execute("SELECT * FROM example_table WHERE id = ?", (user_id,)).fetchone()
            if user:
                user = list(user)
                user[2] = Str_in_List(user[2]) if user[2] else []
                user[3] = Str_in_List(user[3]) if user[3] else []
                return user, True
            return None, False
    except Exception as e:
        print(f"Ошибка при получении пользователя: {e}")
        return None, False

def save_user(user_id, name=None, artefact=None, special_info=None, current_map=0, checking_ship=False):
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            existing_user = cursor.execute("SELECT * FROM example_table WHERE id = ?", (user_id,)).fetchone()
            if not existing_user:
                print(f"Пользователь с ID {user_id} не найден!")
                return False
            # Обновляем только переданные поля
            if name is not None:
                cursor.execute("UPDATE example_table SET name = ? WHERE id = ?", (name, user_id))
            if artefact is not None:
                cursor.execute("UPDATE example_table SET artefact = ? WHERE id = ?", (List_in_Str(artefact), user_id))
            if special_info is not None:
                cursor.execute("UPDATE example_table SET special_info = ? WHERE id = ?", (List_in_Str(special_info), user_id))
            cursor.execute("UPDATE example_table SET current_map = ?, checking_ship = ? WHERE id = ?",
                           (current_map, int(checking_ship), user_id))
            print(f"Пользователь с ID {user_id} успешно обновлен!")
            return True
    except Exception as e:
        print(f"Ошибка при обновлении пользователя: {e}")
        return False

def get_all_user_ids():
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            user_ids = cursor.execute("SELECT id FROM example_table").fetchall()
            return [user_id[0] for user_id in user_ids]
    except Exception as e:
        print(f"Ошибка при получении списка ID пользователей: {e}")
        return []




------------------------------------------------------------
data_operators\maps_operator.py:
from data_operators import pickle_operator
from core.maps_list import maps

saved_maps_path = "data\maps.pkl"


def save_maps():
    success, exception = pickle_operator.try_save_data(maps, saved_maps_path)
    if success:
        print("Карты успешно сохранены")

def load_maps():
    success, exception = pickle_operator.try_load_data(saved_maps_path)
    if success:
        print("Карты успешно сохранены")




------------------------------------------------------------
data_operators\pickle_operator.py:
import pickle


def try_save_data(data, path):
    """
    :param data: Данные для сохранения
    :param path: Путь
    :return: (успех операции, отчёт об ошибке(если есть))
    """
    try:
        with open(path, 'wb') as file:
            pickle.dump(data, file)
            return True, None
    except Exception as exception:
        return False, exception


def try_load_data(path):
    """
    :param path: Путь файла для загрузки
    :return: (загруженные данные или None в случае ошибки, отчёт об ошибке(если есть))
    """
    try:
        with open(path, 'rb') as file:
            return pickle.load(file), None
    except Exception as exception:
        return False, exception



------------------------------------------------------------
mechanics\game_core.py:
import asyncio
import time

#from signal import pthread_sigmask

from core.maps_list import maps
from core.vector2 import Vector2
from core.action import ActionType
from UI.map_visualizer import update_map_message_of_user

# Импорт объектов карты
from models.user import User
from models.world_objects.ship import Ship

from settings.global_settings import render_out_of_border_range

from data_operators.maps_operator import save_maps_to_file


game_active = True
short_step_delay = 1 # Период обновления быстрых явлений(полёт снаряда, эффект взрыва и т. д.)
step_delay = 5 # Стандартный период обновления(передвижения корабля, совершение погружения и т. д.); ДОЛЖЕН БЫТЬ КРАТНЫМ short_step_delay !!!





# Запускает автоматическое совершение запланированных действие с заданным интервалом
async def process_game():
    if step_delay % short_step_delay != 0:
        raise Exception("$ Невозможно запустить game_core.process_game, так как step_delay не кратен short_step_delay, а это условие обязательно")

    '''test_map = maps[0]
    test_user = User(5609117794)
    test_ship = Ship(owner=test_user, sprite_name=f"ship {2}", position=Vector2(2, 5), rotation=90, max_hp=100)
    test_ship2 = Ship(owner=None, sprite_name=f"ship {4}", position=Vector2(1, 2), rotation=180, max_hp=100)
    test_user.controlled_ship = test_ship
    test_user.current_map = test_map
    test_action = Action(object_=test_ship, action_type=ActionType.move, value=180)
    test_map.add_new_object(test_ship)
    test_map.add_new_object(test_ship2)
    test_map.add_new_delayed_action(test_action)'''

    short_step_num = 0
    short_steps_in_basic_step = int(step_delay / short_step_delay) # Раз в сколько быстрых обновлений делать стандартное обновление
    while game_active:
        await asyncio.sleep(short_step_delay)
        for map_ in maps.values():
            process_map_iteration(map_, True)
            short_step_num += 1
            if short_step_num >= short_steps_in_basic_step:
                process_map_iteration(map_, False)
                short_step_num = 0

            update_visual_map(map_)


# Совершение запланированных действий
def process_map_iteration(map_, short_update):
    if not short_update:
        delayed_actions_list = map_.delayed_actions
    else:
        delayed_actions_list = map_.short_delayed_actions

    delayed_actions_to_remove = []
    for delayed_action in delayed_actions_list:
        object_ = delayed_action.object_
        action_type = delayed_action.action_type
        if action_type == ActionType.move:
            map_.add_changed_square(object_)
            if type(object_) == Ship:
                object_.move(delayed_action.value)

        # Добавляем действие в список на удаление
        delayed_actions_to_remove.append(delayed_action)

        # Помечаем также квадрат на котором стоит объект сейчас на случай если он сдвинулся
        map_.add_changed_square(object_)

    # Удаляем выполненные запланированные действия
    if short_update:
        for action_to_remove in delayed_actions_to_remove:
            map_.short_delayed_actions = [action for action in map_.short_delayed_actions if not action == action_to_remove]
    else:
        for action_to_remove in delayed_actions_to_remove:
            map_.delayed_actions = [action for action in map_.delayed_actions if not action == action_to_remove]


# Обновление визуальных карт у игроков, которым это необходимо
def update_visual_map(map_):
    showed_changed_squares = dict() # Сюда добавляем квадраты на карте, которые уже были "погашены", то есть игроки их увидели
    users_to_update_map = dict()
    for object_ in map_.objects:
        if type(object_) == Ship and type(object_.owner) == User:
            min_view_limits = object_.position.summ(Vector2(-object_.view_range - render_out_of_border_range, -object_.view_range - render_out_of_border_range))
            max_view_limits = object_.position.summ(Vector2(object_.view_range + render_out_of_border_range, object_.view_range + render_out_of_border_range))

            for changed_square in map_.changed_squares:
                # Проверка лежит ли изменённый квадрат в области видимости игрока
                if min_view_limits.x <= changed_square.x <= max_view_limits.x and min_view_limits.y <= changed_square.y <= max_view_limits.y:
                    showed_changed_squares[Vector2(changed_square.x, changed_square.y)] = True
                    users_to_update_map[object_.owner] = True

    # Сохраняет карту
    if len(users_to_update_map.keys()) != 0:
        t = time.time()
        save_maps_to_file(maps, "maps.json")
        print(f"Время сохранения карт : {time.time()-t}")

    # Отсылаем карты заново кому надо
    for user in users_to_update_map.keys():
        asyncio.create_task(update_map_message_of_user(user))

    # Удаляем "погашенные" квадраты из списка
    for showed_changed_square in showed_changed_squares.keys():
        map_.changed_squares = [changed_square for changed_square in map_.changed_squares if not changed_square.equals(showed_changed_square)]




------------------------------------------------------------
models\async_event.py:

import asyncio

class AsyncEvent:
    def __init__(self):
        self._subscribers = []

    # Подписаться на событие (поддерживаются как асинхронные, так и синхронные функции)
    def subscribe(self, callback):
        self._subscribers.append(callback)

    # Вызвать событие
    def trigger(self, *args, **kwargs):
        for callback in self._subscribers:
            if asyncio.iscoroutinefunction(callback):
                asyncio.run(callback(*args, **kwargs))  # Асинхронный обработчик
            else:
                callback(*args, **kwargs)  # Синхронный обработчик




------------------------------------------------------------
models\event.py:
import asyncio

class Event:
    def __init__(self):
        self.handlers = []

    def add_handler(self, handler):
        self.handlers.append(handler)

    def trigger(self, *args, **kwargs):
        for handler in self.handlers:
            asyncio.create_task(handler(*args, **kwargs))



------------------------------------------------------------
models\map.py:
import asyncio
import copy
from asyncio import create_task

from UI import map_visualizer
from core.maps_list import maps
from models.user import User
from models.world_objects.ship import Ship
from network import async_messages_operator


class Map:
    def __init__(self):
        self.objects = []
        self.delayed_actions = [] # Действия, находящиеся в списке ожидания (передвижение корабля/существа, ныряние, постройка и т. д.)
        self.short_delayed_actions = []  # Короткие действия, находящиеся в списке ожидания (полёт снаряда, взрыв и т. д.)
        self.changed_squares = [] # Квадраты, на которых в были зафиксированы изменения(если такой квадрат находиться в поле видимости у игрока, то стоит перевыслать ему изображение карты)

    def add_new_object(self, object_):
        self.objects.append(object_)
        self.add_changed_square(object_)

    def add_new_delayed_action(self, new_action, short_action = False, override = True):
        """
        Добавляет ожидаемое действие в список действий на карте
        :param new_action: Сюда подавать экземпляр класса Action
        :param short_action: Короткое ли это действие
        :param override: Да = перезапишет запланированное действие этого объекта если уже есть другое, нет = добавит ещё одно в любом
        """
        # Обновляем сообщение карты, чтобы добавить кнопку Отмена
        if not short_action and type(new_action.object_) == Ship and type(new_action.object_.owner) == User:
            asyncio.create_task(map_visualizer.update_map_message_of_user(new_action.object_.owner, True))
            pass


        if not short_action:
            actions_list = self.delayed_actions
        else:
            actions_list = self.short_delayed_actions

        if override:
            actions_list = [action for action in actions_list if action.object_ != new_action.object_]
        actions_list.append(new_action)

        if not short_action:
            self.delayed_actions = actions_list
        else:
            self.short_delayed_actions = actions_list

    def check_if_object_has_delayed_actions(self, object_, short_actions = False):
        """Проверяет есть ли у объекта ожидаемые действия. Полезно для проверки есть ли уже у корабля действия в списке ожиданий, чтобы он не мог совершить более 1 действия за ход"""
        if not short_actions:
            delayed_actions_list = self.delayed_actions
        else:
            delayed_actions_list = self.short_delayed_actions

        for delayed_action in delayed_actions_list:
            if delayed_action.object_ == object_:
                return True
        return False

    def cancel_object_delayed_actions(self, object_):
        """Удаляет все отложенные действия объекта (кроме short actions, их отменить нельзя)"""
        self.delayed_actions = [action for action in self.delayed_actions if action.object_ != object_]

    def add_changed_square(self, object_):
        self.changed_squares.append(copy.deepcopy(object_.position))




------------------------------------------------------------
models\skill.py:
from enum import Enum

skill = {
"leg" :[
    'Бог морей',  # Значительный бонус к управлению кораблём
    'Бессмертный',  # Обладательнавыка не может иметь меньше 1 хп
    'Проводник душ'# Получает +1 бонусное очко за каждого погибшего члена экипажа с вероятностью (100 - n*10)% где n - количество бонусов полученых таким образом
],
"rare" :[
    'Китобой',  # бонус к урону по монстрам
    'Мертвец',  # уменьшаем стамину увеличиваем живучесть
    'Жрец',  # Может востонавить 1 ХП самому раненому члену экипажа если погиб члон экипажа
    'Везунчик',  # При HP = 0 c 50% вероятностью востонавливает 1 хп
    'Медик',  # Может с 5% вероятностью востонавить 1 хп самому раненому члену экипажа
    'Плотник 2'  # Может с 10% вероятностью востонавить 1 хп кораблю
],
"simple" : [
    'Плотник',  # Может с 5% вероятностью востонавить 1 хп кораблю
    'Охотник за головами',  # При обордаже имеет бонус к атаке 2
    'Стрелок',  # при атаке на монстров имеет опыт в атаке 2
    'Боец',  # Бонус к атаке 1
    'Охотник'  # При атаке монстром или защите от него +2 к Управлению  и  +2 к атаке
]}




------------------------------------------------------------
models\user.py:
from data_operators.BD_init import add_user, get_user, save_user

from data_operators.BD_init import get_all_user_ids


# Класс пользователя, хранящий его достижения, настройки, и т. д.
class User:
    def __init__(self, user_id):
        global users_dict
        #Тут часто используемые
        self.id = user_id
        self.name = ' ___ '
        self.artefacts = []
        self.special_info = []
        self.current_map = 0
        self.map_message_id = None

        self.controlled_ship = None;  """Задавать с помощью ship.register_owner(owner)"""


        #получение информации об игроке с таким ID из базы данных
        user, examination = get_user(user_id)

        
        if examination:
            self.name, self.artefacts, self.special_info, self.controlled_ship, self.current_map  = user[1:]

            if self.current_map is None:
                self.current_map = 0
        else:
            self.__new_user()
            #self.controlled_ship = Ship(self,Vector2(0,0),0, "ship 1",100, 4)
            #maps[0].add_new_object(self.controlled_ship)
            #print(maps[0].objects)
            #maps[0].add_new_object(Ship(self, Vector2(2, 2), 0, "ship 3", 100, 4))
        users_dict[user_id] = self




    def __new_user(self, name = "No name", artefacts=None, special_info = None):
        add_user(self.id,name)

    def save_user(self):
        save_user(self.id, self.name, self.artefacts, self.special_info, self.current_map, checking_ship =
                    self.controlled_ship is None)


users_id  = get_all_user_ids()
users_dict = {}

for i in users_id:
    User(i)



------------------------------------------------------------
models\world_objects\Character.py:
import random
from models.skill import skill


# Части имени
nicknames = [
    "Черный", "Красный", "Золотой", "Серебряный", "Бешеный",
    "Кровавый", "Железный", "Штормовой", "Теневой", "Дикий",
    "Грозный", "Безумный", "Хитрый", "Соленый", "Скалистый",
    "Буряной", "Огненный", "Ночной", "Грозовой", "Ледяной",
    "Яростный", "Ветряной", "Призрачный", "Лунный", "Адский",
    "Королевский", "Бесстрашный", "Светлый", "Бронзовый", "Чумной",
    "Мрачный", "Пылающий", "Песчаный", "Костяной", "Болотный",
    "Тёмный", "Буревестный", "Облачный", "Охотничий", "Снежный",
    "Молниеносный", "Солнечный", "Голодный", "Тихий", "Беспощадный",
    "Лютый", "Стальной", "Бледный", "Коварный", "Бессмертный",
    "Грозящий", "Крылатый", "Вечный", "Мертвенный", "Бушующий",
    "Духовный", "Вихревой", "Трёхглавый", "Звёздный", "Огромный",
    "Чёрствый", "Разрушительный", "Титанический", "Древний", "Водяной",
    "Горящий", "Каменный", "Роковой", "Пыльный", "Светящийся",
    "Пепельный", "Гибельный", "Морозный", "Тропический", "Лесной",
    "Холодный", "Благородный", "Медный", "Ослепительный", "Алмазный",
    "Сквозной", "Грозовой", "Чёрный", "Кристальный", "Туманный",
    "Пьянящий", "Жаркий", "Жестокий", "Зловещий", "Бурлящий"
]

# Основы
bases = [
    "Джек", "Энн", "Морган", "Крюк", "Флинт", "Ворон",
    "Клык", "Костяной", "Борода", "Рейвен", "Волк", "Карабин",
    "Шпагат", "Охотник", "Морской", "Разбойник", "Капитан",
    "Ястреб", "Змея", "Тигр", "Орел", "Таран", "Ланс",
    "Варвар", "Барон", "Дракон", "Лансер", "Кочевник",
    "Акула", "Тарантул", "Сокол", "Вождь", "Медведь",
    "Грифон", "Пират", "Гладиатор", "Всадник", "Призрак",
    "Штурман", "Гарпун", "Зверь", "Тень", "Китобой",
    "Стрелок", "Бандит", "Тюлень", "Шаман", "Сапсан",
    "Корсар", "Сокол", "Саламандра", "Чудовище", "Легионер",
    "Лев", "Палач", "Тритон", "Минотавр", "Громовержец",
    "Олень", "Странник", "Сирена", "Охотник", "Арбалетчик",
    "Бык", "Чёрт", "Зодчий", "Хищник", "Дельфин",
    "Зверолов", "Зверобой", "Мастер", "Ткач", "Гончар",
    "Сокол", "Морж", "Альбатрос", "Орлан", "Дервиш",
    "Ветер", "Летучий", "Хранитель", "Молот", "Гигант",
    "Бык", "Шип", "Змей", "Рысь", "Пастырь",
    "Моряк", "Старейшина", "Пантера", "Шторм", "Воевода"
]


def generate_pirate_name():
    nickname = random.choice(nicknames)
    base = random.choice(bases)
    return f"{nickname} {base}"


class Character:
    def __init__(self, lid = False, bon = 0):
        """

        :param lid: Лидер Гарантировано получит навык + на корабле может быть только 1 лидер, в случае если их возникает 2 то выбирается лучший
        :param bon: Добавляет характеристики к базовым 5 бонусам
        """

        self.name = generate_pirate_name()
        self.skill = None

        point = 5 + bon

        self.lid = lid

        self.control = 1
        self.harvest = 1
        self.attack = 1
        self.survival = 1
        self.stamina = 1

        while point > 0:
            if random.randint(1,6) == 1:
                self.control += 1
            elif random.randint(1,5) == 1:
                self.harvest += 1
            elif random.randint(1,4) == 1:
                self.attack += 1
            elif random.randint(1,3) == 1:
                self.survival += 1
            else:
                self.stamina += 2
            point -= 1
        self.__skill_gen()





    def __skill_gen(self):
        if random.randint(1,100) == 1 or self.lid:
            if random.randint(1,100) == 1:
                self.skill = random.choice(skill['leg'])
            elif random.randint(1,1000) < 101:
                self.skill = random.choice(skill['rare'])
            else:
                self.skill = random.choice(skill['simple'])

        if self.skill == 'Боец':
            self.attack += 1
        elif self.skill == 'Мертвец':
            self.stamina = max(1,int(self.stamina/2))
            self.survival *= 2
        elif self.skill == 'Бог морей':
            self.control += 3









------------------------------------------------------------
models\world_objects\game_object.py:

class GameObject:
    def __init__(self, position, rotation = 0, image_path = None):
        self.position = position
        self.rotation = rotation
        self.image_path = image_path




------------------------------------------------------------
models\world_objects\island.py:
from core.vector2 import Vector2
from models.world_objects.game_object import GameObject


class Island(GameObject):
    def __init__(self, position, local_points=None, local_visual_points=None):
        if local_visual_points is None:
            local_visual_points = [(0.5, 0.5), (-0.5, 0.5), (-0.5, -0.5), (0.5, -0.5)]
        if local_points is None:
            local_points = [Vector2(0, 0)]

        super().__init__(position)
        self.local_points = local_points
        self.local_visual_points = local_visual_points




------------------------------------------------------------
models\world_objects\monster.py:
from models.world_objects.game_object import GameObject


class Monster(GameObject):
    def __init__(self, position, rotation, sprite_name, max_hp, view_range = 3, freeze_rotation=False, updates_to_move = 1):
        super().__init__(position, rotation)




------------------------------------------------------------
models\world_objects\ship.py:
from core.images_operator import get_image_path_from_ship_name
from core.vector2 import Vector2
from models.user import User
from models.world_objects.game_object import GameObject
from models.world_objects.Character import Character


# Класс корабля, хранящий его статы
class Ship(GameObject):
    def __init__(self, position, rotation, sprite_name, max_hp = 100, view_range = 4):
        """
        :param position: Стартовая позиция
        :param rotation: Стартовый поворот
        :param sprite_name: Название текстуры
        :param max_hp: Максимальные ХП
        :param view_range: Радиус обзора в клетках (целое)
        """
        super().__init__(position, rotation, get_image_path_from_ship_name(sprite_name))
        self.owner = None
        self.max_hp = max_hp
        self.hp = max_hp
        self.view_range = view_range

        self.onboard_team = []

        self.onboard_team.append(Character(True, 1))
        self.onboard_team.append(Character())
        self.onboard_team.append(Character())

    def register_owner(self, owner):
        """Регистрирует владельца корабля"""
        self.owner = owner
        if type(owner) == User:
            breakpoint()
            owner.controlled_ship = self
        else:
            print("\n"*10)
            print("$ Warning : The owner of the ship is not User (ship.py)")
            print("\n" * 3)


    def move(self, direction):
        self.rotation = direction
        match direction:
            case 0:  # Вверх
                self.position.add(Vector2(0, 1))
            case 45:
                self.position.add(Vector2(-1, 1))
            case -45:
                self.position.add(Vector2(1, 1))
            case 90:
                self.position.add(Vector2(-1, 0))
            case -90:
                self.position.add(Vector2(1, 0))
            case 135:
                self.position.add(Vector2(-1, -1))
            case -135:
                self.position.add(Vector2(1, -1))
            case 180:
                self.position.add(Vector2(0, -1))


    def take_damage(self,damage):
        """
        Функция получения кораблём урона и проверки на уничтожение.
        :param damage: Целое положительное число
        :return: удалось ли этой атаке уничтожить корабль
        """
        self.hp -= damage
        if self.hp < 0:
            return True
        else:
            return False
        # При hp <= 0 корабль должен получать урон за каждое перемещение с шансом, зависящим от опыта управления капитана






------------------------------------------------------------
network\async_messages_operator.py:
from variables.bot import bot
import asyncio
from aiogram.types import Message, InputMediaPhoto
import random
from core import images_operator


async def try_delete_message(chat_id, message_id) -> bool:
    try:
        await bot.delete_message(chat_id=chat_id, message_id=message_id)
        return True
    except Exception as exception:
        print(f'$ Warning - message {message_id} in chat {chat_id} cannot be deleted: {exception}')
        return False


async def try_edit_message_text(chat_id, message_id, new_message_text) -> bool:
    try:
        await bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=new_message_text)
        return True
    except Exception as exception:
        print(f"$ Warning - message's {message_id} text in chat {chat_id} cannot be edited to '{new_message_text}': {exception}")
        return False

'''async def test_edit():
    message_id = 0
    while True:
        await asyncio.sleep(1)
        result, new_message_id = await try_strong_edit_message_media(5609117794,
                                                               message_id,
                                                               f"Абобус {random.randint(0, 100)}",
                                                               images_operator.get_image_from_ship_name(f"ship {random.randint(1, 5)}"),
                                                               max_edit_wait_time=1)
        if result:
            message_id = new_message_id
        else:
            print("Завершение")
            break'''

async def try_strong_edit_message_media(
    chat_id,
    message_id,
    new_caption=None,
    new_photo=None,
    new_reply_markup=None,
    max_edit_wait_time=1
) -> (bool, int):
    """
    Изменяет сообщение, при неудаче пытается удалить сообщение с message_id и выслать новое(в таком случае вернёт id нового сообщения, иначе - изменённого)
    :param chat_id: id чата
    :param message_id: id сообщения
    :param new_caption: новая подпись
    :param new_photo: новое фото
    :param new_reply_markup: новый reply_markup
    :param max_edit_wait_time: максимальное время ожидания изменения сообщения(при превышении перевышлется)
    :return: удачно ли изменено, id изменённого сообщения(оно могло измениться)
    """
    try:
        # Запускаем редактирование сообщения
        if new_photo is not None:
            task = asyncio.create_task(
                bot.edit_message_media(
                    chat_id=chat_id,
                    message_id=message_id,
                    media=InputMediaPhoto(media=new_photo, caption=new_caption),
                    reply_markup=new_reply_markup
                )
            )
        else:
            task = asyncio.create_task(
                bot.edit_message_caption(
                    chat_id=chat_id,
                    message_id=message_id,
                    caption=new_caption,
                    reply_markup=new_reply_markup
                )
            )

        # Ждем завершения редактирования в пределах max_edit_wait_time
        done, pending = await asyncio.wait([task], timeout=max_edit_wait_time)

        # Если задача завершилась
        try:
            if task in done:
                await task  # Проверяем на исключения
                print("Успешно изменено")
                return True, message_id
        except:
            pass

        # Если задача не завершилась, отменяем ее и обрабатываем
        for pending_task in pending:
            pending_task.cancel()

        print("Не удалось изменить сообщение, перевысылаю...")

        # Удаляем старое сообщение
        try:
            asyncio.create_task(try_delete_message(chat_id=chat_id, message_id=message_id))
        except:
            pass

        # Отправляем новое сообщение
        if new_photo is not None:
            new_message: Message = await bot.send_photo(
                chat_id=chat_id,
                photo=new_photo,
                caption=new_caption,
                reply_markup=new_reply_markup
            )
        else:
            return False, None

        print("Перевыслано успешно")
        return True, new_message.message_id

    except Exception as exception:
        print(f"$ Warning - message's {message_id} in chat {chat_id} could not be edited or replaced: {exception}")
        return False, None




------------------------------------------------------------
network\call_reaction.py:
from variables.event_manager import call_event
from variables.bot import  dp
from core.users_list import users_dict
from models.user import User

#Обработчик текста
@dp.callback_query()
async def text_receiver(message):
    if message.message.chat.id > 0:
        if not message.message.chat.id in users_dict.keys():
            User(message.message.chat.id)
        call_event.trigger(message = message)
    else:
        await message.message.bot.send_message(message.message.chat.id, "Недоступно в чатах")




------------------------------------------------------------
network\text_reaction.py:
import asyncio

from variables.event_manager import text_event
from variables.bot import  dp
from aiogram.filters import Command
from aiogram import types
from core.users_list import users_dict
from models.user import User
from network import async_messages_operator

#Обработчик текста
@dp.message()
async def text_receiver(message: types.Message):
    asyncio.create_task(async_messages_operator.try_delete_message(message.chat.id, message.message_id))
    if message.chat.id > 0:
        if not message.chat.id in users_dict.keys():
            User(message.chat.id)
        text_event.trigger(message = message)
    else:
        await message.bot.send_message(message.chat.id, "Недоступно в чатах")






------------------------------------------------------------
settings\global_settings.py:
from settings import not_synchronized

token = not_synchronized.bot_token
render_out_of_border_range = 0  # Дополнительная прорисовка за краями карты. Установите на 0, если хотите, чтобы игрок никак не мог увидеть, что находится за краями его поля зрения и на 1, если хотите оставить возможность увидеть выглядывающий объект из-за краёв карты



------------------------------------------------------------
settings\not_synchronized.py:
# Этот файл не должен синхронизироваться в боте
bot_token = '7341501133:AAEToBm5cNmHILAYMRdKbOnKdrzxYkHkjDI'



------------------------------------------------------------
settings\special_persons.py:

# 5023003261 - Loki, 5609117794 - Lomi, 6843891842 - Зенон, 5125398596 - jon1k, 498216118 - 🙇🏼‍♂️Dimarikann🙇🏼‍♂️, 6014738757 - Ekwensu
admins = [5609117794, 5023003261, 6014738757]
developers = [5609117794, 5023003261]




------------------------------------------------------------
UI\inline_keyboard_buttons.py:
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton


ship_control_buttons = InlineKeyboardMarkup(
    inline_keyboard=[
        [InlineKeyboardButton(text="⬉", callback_data="⬉"),InlineKeyboardButton(text="↑", callback_data="↑"),InlineKeyboardButton(text="⬈", callback_data="⬈")],
        [InlineKeyboardButton(text="←", callback_data="←"),InlineKeyboardButton(text="🔵", callback_data="🔵"),InlineKeyboardButton(text="→", callback_data="→")],
        [InlineKeyboardButton(text="⬋", callback_data="⬋"),InlineKeyboardButton(text="↓", callback_data="↓"),InlineKeyboardButton(text="⬊", callback_data="⬊")],
    ]
)

cancel_button = InlineKeyboardMarkup(
    inline_keyboard=[
        [InlineKeyboardButton(text="Отмена 🚫", callback_data="cancel")]
    ]
)


"""Однотонные квадраты:
◼️ Черный квадрат
◻️ Белый квадрат
▪️ Маленький черный квадрат
▫️ Маленький белый квадрат
Цветные квадраты:
🔴 Красный квадрат
🟠 Оранжевый квадрат
🟡 Желтый квадрат
🟢 Зеленый квадрат
🔵 Синий квадрат
🟣 Фиолетовый квадрат
🟤 Коричневый квадрат
⚫ Черный (круглый) квадрат
⚪ Белый (круглый) квадрат
Границы:
⬛ Черный большой квадрат
⬜ Белый большой квадрат"""



------------------------------------------------------------
UI\keyboard_buttons.py:
from aiogram import types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

button_map = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="Карта 🗺")]
            ],
            resize_keyboard=True  # Уменьшаем размер кнопки
        )



------------------------------------------------------------
UI\map_visualizer.py:
import math
import time
import cv2
import numpy as np
from aiogram import types
import random
import asyncio

from UI import inline_keyboard_buttons
from core import images_operator
from core.maps_list import maps
from core.users_list import users_id
from core.vector2 import Vector2
from models.world_objects.ship import Ship
from network.async_messages_operator import try_delete_message
from variables.bot import bot
from settings.global_settings import render_out_of_border_range
from network import async_messages_operator

def create_background(width, height, color=(252, 141, 56)):  # RGB вместо HEX
    """Создание фона."""
    return np.full((height, width, 3), color, dtype=np.uint8)


def render_visible_objects(base_image, map_, player_ship):
    """Добавление видимых объектов на изображение."""
    full_view_range = player_ship.view_range + render_out_of_border_range
    min_visible_pos = player_ship.position.summ(Vector2(-full_view_range, -full_view_range))
    max_visible_pos = player_ship.position.summ(Vector2(full_view_range, full_view_range))
    resolution = base_image.shape[0]
    pixels_in_cell = resolution / (player_ship.view_range * 2 + 1)

    for object_ in map_.objects:
        # Проверка на то, находиться ли объект в поле видимости
        if min_visible_pos.x <= object_.position.x <= max_visible_pos.x and min_visible_pos.y <= object_.position.y <= max_visible_pos.y:
            relative_cells_pos = object_.position.summ(Vector2(-player_ship.position.x, -player_ship.position.y))
            pixels_pos = Vector2(relative_cells_pos.x * pixels_in_cell, -relative_cells_pos.y * pixels_in_cell).summ(Vector2(resolution / 2, resolution / 2))
            add_object(base_image, object_, pixels_pos, object_.rotation, pixels_in_cell)


def add_object(base_image, object_, position, rotation, pixels_in_cell):
    """Рендерит один отдельный объект с указанными позицией в пикселях(0, 0 = левый верхний угол) и поворотом в градусах"""
    object_type = type(object_)

    if object_type == Ship:
        # Получаем изображение корабля в нужном формате
        ship_img = images_operator.get_cv2_image_from_path(object_.image_path)

        # Масштабируем изображение корабля
        additive_scale = 1.1  # Дополнительное увеличение изображения (если хотите чтобы картинка слегка вылазила за грани ячейки)
        scale = pixels_in_cell / max(ship_img.shape[0], ship_img.shape[1])

        add_image(base_image, ship_img, position, rotation, scale * additive_scale)


def add_image(base_image, image, position, rotation=0, scale=1.0):
    """
    Добавляет изображение на base_image с учетом позиции, поворота и масштаба.

    :param base_image: Основное изображение (numpy array).
    :param image: Накладываемое изображение (numpy array с альфа-каналом).
    :param position: Центр наложения Vector2(x, y) на base_image.
    :param rotation: Угол поворота (в градусах).
    :param scale: Масштаб изображения.
    """
    # Убедимся, что изображение с альфа-каналом
    if image.shape[2] != 4:
        raise ValueError("Изображение должно содержать альфа-канал (4 канала)")

    # Масштабируем изображение
    new_size = (int(image.shape[1] * scale), int(image.shape[0] * scale))
    scaled_image = cv2.resize(image, new_size, interpolation=cv2.INTER_LANCZOS4)

    # Поворачиваем изображение
    center = (scaled_image.shape[1] // 2, scaled_image.shape[0] // 2)
    rotation_matrix = cv2.getRotationMatrix2D(center, rotation, 1)
    rotated_image = cv2.warpAffine(
        scaled_image,
        rotation_matrix,
        (scaled_image.shape[1], scaled_image.shape[0]),
        flags=cv2.INTER_LINEAR,
        borderMode=cv2.BORDER_CONSTANT,
        borderValue=(0, 0, 0, 0)
    )

    # Определяем позиции вставки
    x, y = int(position.x - rotated_image.shape[1] / 2), int(position.y - rotated_image.shape[0] / 2)

    # Убедимся, что координаты вставки не выходят за границы base_image
    x_start, x_end = max(0, x), min(base_image.shape[1], x + rotated_image.shape[1])
    y_start, y_end = max(0, y), min(base_image.shape[0], y + rotated_image.shape[0])

    # Рассчитываем координаты для cropped region
    crop_x_start = max(0, -x)
    crop_x_end = crop_x_start + (x_end - x_start)
    crop_y_start = max(0, -y)
    crop_y_end = crop_y_start + (y_end - y_start)

    # Извлекаем альфа-канал и выполняем наложение
    alpha = rotated_image[crop_y_start:crop_y_end, crop_x_start:crop_x_end, 3] / 255.0
    for c in range(3):  # Каналы RGB
        base_image[y_start:y_end, x_start:x_end, c] = (
            alpha * rotated_image[crop_y_start:crop_y_end, crop_x_start:crop_x_end, c] +
            (1 - alpha) * base_image[y_start:y_end, x_start:x_end, c]
        )


def add_grid(
    base_image,
    cell_count,
    grid_thickness_ratio=0.002,  # Толщина линий относительно ширины изображения
    grid_color=(0, 0, 0, 100),  # Цвет сетки (RGBA)
    text_color=(0, 0, 0, 100),  # Цвет текста (RGBA)
    font_scale_ratio=0.001,  # Размер текста относительно ширины изображения
    font_thickness_ratio=0.0025,  # Толщина текста относительно ширины изображения
    text_offset_ratio=0.005  # Отступ текста от границ изображения
):
    """Добавление сетки с буквами и цифрами на изображение."""
    height, width = base_image.shape[:2]
    cell_width = width // cell_count
    cell_height = height // cell_count

    # Абсолютные значения для толщины линий, размера и толщины текста
    grid_thickness = max(1, int(grid_thickness_ratio * width))
    font_scale = font_scale_ratio * width
    font_thickness = max(1, int(font_thickness_ratio * width))
    text_offset = int(text_offset_ratio * width)

    # Создаем временные слои
    grid_layer = base_image.copy()
    text_layer = base_image.copy()

    # Рисуем линии сетки
    for i in range(1, cell_count):
        x = i * cell_width
        y = i * cell_height

        # Вертикальные линии
        cv2.line(grid_layer, (x, 0), (x, height), grid_color[:3], grid_thickness, lineType=cv2.LINE_AA)

        # Горизонтальные линии
        cv2.line(grid_layer, (0, y), (width, y), grid_color[:3], grid_thickness, lineType=cv2.LINE_AA)

    # Добавляем текст (буквы сверху и снизу, цифры слева и справа)
    for i in range(cell_count):
        letter = chr(65 + i)  # Генерация букв 'A', 'B', ...
        number = str(i + 1)   # Цифры от 1 до cell_count

        # Позиции текста
        letter_x = int(i * cell_width + cell_width / 2)
        letter_top_y = text_offset
        letter_bottom_y = height - text_offset

        number_y = int(i * cell_height + cell_height / 2)
        number_left_x = text_offset
        number_right_x = width - text_offset

        # Центровка текста по границе
        letter_size = cv2.getTextSize(letter, cv2.FONT_HERSHEY_SIMPLEX, font_scale, font_thickness)[0]
        number_size = cv2.getTextSize(number, cv2.FONT_HERSHEY_SIMPLEX, font_scale, font_thickness)[0]

        # Рисуем буквы сверху и снизу
        cv2.putText(
            text_layer, letter,
            (letter_x - letter_size[0] // 2, letter_top_y + letter_size[1]),
            cv2.FONT_HERSHEY_SIMPLEX, font_scale, text_color[:3], font_thickness, lineType=cv2.LINE_AA
        )
        cv2.putText(
            text_layer, letter,
            (letter_x - letter_size[0] // 2, letter_bottom_y),
            cv2.FONT_HERSHEY_SIMPLEX, font_scale, text_color[:3], font_thickness, lineType=cv2.LINE_AA
        )

        # Рисуем цифры слева и справа
        cv2.putText(
            text_layer, number,
            (number_left_x, number_y + number_size[1] // 2),
            cv2.FONT_HERSHEY_SIMPLEX, font_scale, text_color[:3], font_thickness, lineType=cv2.LINE_AA
        )
        cv2.putText(
            text_layer, number,
            (number_right_x - number_size[0], number_y + number_size[1] // 2),
            cv2.FONT_HERSHEY_SIMPLEX, font_scale, text_color[:3], font_thickness, lineType=cv2.LINE_AA
        )

    # Накладываем сетку с ее прозрачностью
    grid_alpha = grid_color[3] / 255.0
    cv2.addWeighted(grid_layer, grid_alpha, base_image, 1 - grid_alpha, 0, base_image)

    # Накладываем текст с его прозрачностью
    text_alpha = text_color[3] / 255.0
    cv2.addWeighted(text_layer, text_alpha, base_image, 1 - text_alpha, 0, base_image)


def get_user_map_image(user):
    start_time = time.perf_counter()
    if user.current_map is not None:
        map_ = maps[user.current_map]
    else:
        raise Exception(f'Невозможно сгенерировать изображение карты пользователю {user.name}, так как user.current_map == None')

    # Задаём размер карты
    resolution = 1024
    cells_num = (user.controlled_ship.view_range * 2) + 1  # Количество клеток на картинке карты

    # Создаем фон
    base_image = create_background(resolution, resolution)

    # Отрисовываем видимые игроку объекты на карте
    render_visible_objects(base_image, map_, user.controlled_ship)

    # Добавляем сетку
    add_grid(base_image, cells_num)

    # Преобразуем изображение
    _, buffer = cv2.imencode('.png', base_image)
    image_bytes = buffer.tobytes()

    print(f'Время генерации картинки карты: {(time.perf_counter() - start_time) * 1000:.1f} мс')
    return types.BufferedInputFile(image_bytes, filename="map.png")


async def update_map_message_of_user(user, dont_update_map_image = False, iteration_num = 0):
    """
    Генерация карты и отправка пользователю
    :param user: Пользователь которому обновить сообщение с картой
    :param dont_update_map_image: При True не обновляет изображение карты(полезно если нужно обновить только кнопки или текст)
    :param iteration_num: Номер попытки, нужен для предотвращения бесконечного цикла
    """
    if iteration_num > 5:
        return

    # Проверяем заданы ли у юзера корабль и карта
    if user.controlled_ship is None:
        print(f"Невозможно отобразить карту игроку {user.name}, так как у него не задан controlled_ship")
        return
    if user.current_map is None:
        print(f"Невозможно отобразить карту игроку {user.name}, так как у него не задан current_map")
        return

    if not dont_update_map_image:
        map_image = get_user_map_image(user)
    else:
        map_image = None

    # Проверяем есть ли у игрока ожидаемые действия и если да то отображаем кнопку отмены
    if not maps[user.current_map].check_if_object_has_delayed_actions(user.controlled_ship):
        new_reply_markup=inline_keyboard_buttons.ship_control_buttons
    else:
        new_reply_markup=inline_keyboard_buttons.cancel_button

    result, new_message_id = await async_messages_operator.try_strong_edit_message_media(chat_id=user.id, message_id=user.map_message_id, new_photo=map_image, new_caption="Это карта", new_reply_markup=new_reply_markup)
    if result:
        if user.map_message_id != new_message_id:
            asyncio.create_task(try_delete_message(user.id, user.map_message_id))
            user.map_message_id = new_message_id
    else:
        await try_delete_message(user.id, new_message_id)
        user.map_message_id = None
        asyncio.create_task(update_map_message_of_user(user, iteration_num=iteration_num + 1))
        print(f"Неудача изменения сообщения с картой, генерирую и высылаю заново({iteration_num})...")




------------------------------------------------------------
variables\bot.py:
from aiogram import Dispatcher, Bot
from settings.global_settings import token

#инициализируем бота и диспетчер
bot = Bot(token=token, timeout=3)
dp = Dispatcher()



------------------------------------------------------------
variables\event_manager.py:
from models.event import Event

from core.text_reactions.start_reaction import command_start
from core.text_reactions.map_reaction import map_button_reaction

from core.call_reactions.arrows_reaction import arrows_reaction
from core.call_reactions.cancel_reaction import cancel_reaction

text_event = Event()
call_event = Event()

text_event.add_handler(command_start)
text_event.add_handler(map_button_reaction)

call_event.add_handler(arrows_reaction)
call_event.add_handler(cancel_reaction)
